# FA-2, ERC-20 style transfer approvals

let {
  type Parameter =
    ( (Address :from, Nat :val)              %transferFrom
    | (Address :to, Nat :val)                %approve
    | View (Address :from, Address :to) Nat  %getAllowance
    );

  type Storage =
    ( BigMap   %approvals (Address :from) (Map (Address :to) Nat)
    , Address  %ledger
    );

   zeroNone :: '[ Nat, ...] -> '[ Option Nat, ...]
   = { dup; push nat 0; cmpeq; if {drop; none Nat;} {some;}; };

  setAllowance :: '[ Nat, Address :from, Address :to, Storage, ...] -> '[ Storage, ...]
  = { zeroNone; swap; dip {duuup; car;}; dup;
      dip {get; if_none { empty_map Address Nat;} {};};
      stacktype '[ Address :from, Map Address Nat, Option Nat, Address :to, Storage, ...];
      dip {swap; dip {swap}; swap; update};
      stacktype '[ Address :from, Map Address Nat, Storage, ...];
      diip {unpair};
      dip {some};
      update;
      pair;
    };

   allowance :: '[ ((Address :from, Address :to), Storage), ...] -> '[ Nat, ...]
   = { unpair; unpair; dip {swap; car;}; get; assert_some;
       swap; get; if_none {push Nat 0;} {}
     };

   approve :: '[ (Address :to, Nat :val), Storage]
           -> '[ ([Operation], Storage) ]
   = { unpair; swap; dip {source; cast (Address :from);};
       stacktype '[ Nat :val, Address :from, Address :to, Storage];
       duup; duuuup; swap; pair; duuuuup; swap; pair;
       stacktype '[ ((Address :from, Address :to), Storage), ...];
       allowance;
       stacktype '[ Nat, Nat, ...];
       push Nat 0; cmpeq;                     # if allowance is not 0
       if {} {dup; push Nat 0; assert_cmpeq}; # then approve value must be 0
       setAllowance; nil Operation; pair
      };

  type LedgerParameter =
    ( (Address :from, Address :to, Nat :val)     %safeTransfer
    | (Address :to, Nat)                         %mint
    | (Address :from, Nat)                       %burn
    | (Option %setApprover Address)
    | View () Nat                                %getTotalSupply
    | View Address (Option Nat)                  %getBalance
    );

   transferFrom :: '[ (Address :from, Nat :val), Storage ]
                -> '[ ([Operation], Storage) ]
   = { duup; source; duuup; car; pair; pair; 
       stacktype '[((Address :from, Address :to), Storage), ...];
       allowance;
       stacktype '[Nat, (Address :from, Nat :val), Storage];
       duup; cdr; assert_cmpeq; # transfer must exactly equal allowance
       stacktype '[(Address :from, Nat :val), Storage];
       dup; car; dip {swap}; 
       stacktype '[Address :from, Storage, (Address :from, Nat :val)];
       dip {source; cast (Address :to);}; push Nat 0;
       stacktype '[Nat, Address :from, Address :to, Storage, (Address :from, Nat :val)];
       setAllowance;
       swap;
       unpair; dip {source; cast (Address :to);}; papair;
       left ( (Address, Nat)
            | (Address, Nat)
            | Option Address
            | View () Nat
            | View Address (Option Nat)
            );
       stacktype '[LedgerParameter, Storage];
       duup; cdr;
       contract LedgerParameter;
       assert_some;
       swap;
       dip {amount};
       stacktype '[LedgerParameter, Mutez, Contract (LedgerParameter), Storage];
       transfer_tokens;
       nil Operation; swap; cons;
       pair;
    };

   getAllowance :: '[ View (Address :from, Address :to) Nat, Storage ]
             -> '[ ([Operation], Storage) ]
   = { view { allowance }; };

};

parameter Parameter;
storage Storage;
code {unpair;
      case
        { transferFrom }
        { approve      }
        { getAllowance    }
    };

