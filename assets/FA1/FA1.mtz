let {

  getSourceBalance :: '[(Address, Nat), Storage]
                   -> '[Nat, (Address, Nat), Storage]
  = {duup; car; source; get; assert_some; };

  newSourceBalance :: '[Nat, (Address, Nat), Storage]
                   -> '[Option Nat, (Address, Nat), Storage]
  = { duup; cdr; swap; sub; dup; assert_ge;
      dup; eq; if {drop; none Nat} {isnat};
    };

  debitSource :: '[Option Nat, (Address, Nat), Storage] -> '[(Address, Nat), Storage]
  = { dip {swap; unpair}; source; update; pair; swap};

  getRecipientBalance :: '[(Address, Nat), Storage]
                      -> '[Option Nat, (Address, Nat), Storage]
  = { duup; car; duup; car; get};

  newRecipientBalance :: '[Option Nat, (Address, Nat), Storage]
                      -> '[Nat, (Address, Nat), Storage]
  = { if_some
      {duup; cdr; add}
      {dup; cdr};
    };

  creditRecipient :: '[Nat, (Address, Nat), Storage]
                  -> '[(Address, Nat), Storage]
  = { some; duup; car; diip {swap; unpair}; update; pair; swap;};

  transferBalance :: '[(Address, Nat), Storage]
                  -> '[(List Operation, Storage)]
  = { getSourceBalance; newSourceBalance; debitSource;
      getRecipientBalance; newRecipientBalance; creditRecipient;
      drop; nil operation; pair;
    };

  getTotalSupply :: '[ View () Nat, Storage ] -> '[(List Operation, Storage)]
  = { view {cddr} };

  getBalance :: '[ View Address (Option Nat), Storage ]
             -> '[(List Operation, Storage)]
  = { view { unpair; dip {car}; get} };

};
parameter
  ( (Address, Nat)              %transfer
  | View () Nat                 %getTotalSupply
  | View Address (Option Nat)   %getBalance
  );
storage (BigMap Address Nat, Nat);
code {unpair;
      case
        { transferBalance}
        { getTotalSupply }
        { getBalance };
     };
