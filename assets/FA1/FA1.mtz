let {

  type Parameter =
    ( (Address, Nat)              %transfer
    | View () Nat                 %getTotalSupply
    | View Address (Option Nat)   %getBalance
    );

  type Storage = (BigMap Address Nat, Nat);

  getSourceBalance :: '[(Address, Nat), Storage]
                   -> '[Nat, (Address, Nat), Storage]
  = {duup; car; source; get; assert_some; };

  newSourceBalance :: '[Nat, (Address, Nat), Storage]
                   -> '[Nat, (Address, Nat), Storage]
  = { duup; cdr; swap; sub; isnat; assert_some; };

  debitSource :: '[Nat, (Address, Nat), Storage] -> '[(Address, Nat), Storage]
  = { dip {swap; unpair}; some; source; update; pair; swap};

  getRecipientBalance :: '[(Address, Nat), Storage] 
                      -> '[Option Nat, (Address, Nat), Storage]
  = { duup; car; duup; car; get};

  newRecipientBalance :: '[Option Nat, (Address, Nat), Storage]
                      -> '[Nat, (Address, Nat), Storage]
  = { if_some
      {duup; cdr; add}
      {dup; cdr};
    };

  creditRecipient :: '[Nat, (Address, Nat), Storage]
                  -> '[(Address, Nat), Storage]
  = { some; duup; car; diip {swap; unpair}; update; pair; swap;};

  transferBalance :: '[(Address, Nat), Storage]
                  -> '[(List Operation, Storage)]
  = { getSourceBalance; newSourceBalance; debitSource;
      getRecipientBalance; newRecipientBalance; creditRecipient;
      drop; nil operation; pair;
    };

  getTotalSupply :: '[ View () Nat, Storage ] -> '[(List Operation, Storage)]
  = { view {cddr} };

  getBalance :: '[ View Address (Option Nat), Storage ]
             -> '[(List Operation, Storage)]
  = { view { unpair; dip {car}; get} };

};
parameter Parameter;
storage Storage;
code {unpair;
      case
        { transferBalance}
        { getTotalSupply }
        { getBalance };
     };
