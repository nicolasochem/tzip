# FA-1.3 Managed ledger, mintable, burnable, pausable
# compatible with FA-2 transfer approvals

let {

  type Parameter =
    ( (Address :from, Address :to, Nat :val)     %safeTransfer
    | (Address :to, Nat)                         %mint
    | (Address :from, Nat)                       %burn
    | (Option %setApprover Address)
    | View () Nat                                %getTotalSupply
    | View Address (Option Nat)                  %getBalance
    );

  type Storage =
    ( (BigMap %ledger Address Nat)
    , Nat     %totalSupply
    , (Option %approver Address)
    , Address %centralBank
    );

  getFromBalance :: '[(Address :from, Nat), Storage, ...]
                   -> '[Nat, (Address :from, Nat), Storage, ...]
  = {duup; car; duup; car; get; assert_some; };

  subtractBalance :: '[Nat, (Address, Nat), Storage, ...]
                  -> '[Option Nat, (Address, Nat), Storage, ...]
  = { duup; cdr; swap; sub; dup; assert_ge;
      dup; eq; if {drop; none Nat} {isnat};
    };

  debitFrom :: '[Option Nat, (Address :from, Nat), Storage, ...]
            -> '[(Address :from, Nat), Storage, ...]
  = { duup; car;
      diip {swap; unpair};
      update; pair; swap};

  getToBalance :: '[(Address :to, Nat), Storage, ...]
               -> '[Option Nat, (Address :to, Nat), Storage, ...]
  = { duup; car; duup; car; get};

  newToBalance :: '[Option Nat, (Address :to, Nat), Storage, ...]
               -> '[Nat, (Address :to, Nat), Storage, ...]
  = { if_some
      {duup; cdr; add}
      {dup; cdr};
    };

  updateBalance :: '[Nat, (Address, Nat), Storage, ...]
           -> '[(Address, Nat), Storage, ...]
  = { some; duup; car;
      diip {swap; unpair};
      update; pair; swap;};

  sourceIsBank :: '[Storage] -> '[Bool, Storage]
  = { dup; cdddr; source; cmpeq};

  senderIsApprover :: '[Storage] -> '[Bool, Storage]
  = { dup; cddar; if_some {sender; cmpeq} {push Bool False;} };

  setApprover :: '[ Option Address, Storage] -> '[ ([Operation], Storage) ]
  = { dip {sourceIsBank; assert;};
      dip {unpapapair}; swap; dip {swap; dip {swap; drop;}};
      papapair;
      nil Operation; pair;};

  mintBalance :: '[(Address :to, Nat), Storage]
              -> '[([Operation], Storage)]
  = { dip {sourceIsBank; assert;};
      getToBalance; newToBalance; updateBalance;
      drop; nil Operation; pair;
    };

  burnBalance :: '[(Address :from, Nat), Storage]
              -> '[([Operation], Storage)]
  = { dip {sourceIsBank; assert;};
      getFromBalance;
      subtractBalance;
      assert_some;
      updateBalance;
      drop; nil operation; pair
    };

  transferBalance :: '[(Address :from, Address :to, Nat), Storage]
                  -> '[([Operation], Storage)]
  = { dip {sourceIsBank; dip {senderIsApprover}; or; assert;};
      swap; duup; unpapair; dip {drop}; pair;
      getFromBalance; subtractBalance; debitFrom;
      drop; duup; unpapair; drop; pair;
      getToBalance; newToBalance; updateBalance;
      drop; dip {drop}; nil Operation; pair;
    };

  getTotalSupply :: '[ View () Nat, Storage ] -> '[(List Operation, Storage)]
  = { view {cddar} };

  getBalance :: '[ View Address (Option Nat), Storage ]
             -> '[(List Operation, Storage)]
  = { view { unpair; dip {car}; get} };

};
parameter Parameter;
storage Storage;
code {unpair;
      case
        { transferBalance}
        { mintBalance}
        { burnBalance}
        { setApprover }
        { getTotalSupply }
        { getBalance };
     };
